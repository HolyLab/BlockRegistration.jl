var documenterSearchIndex = {"docs":
[{"location":"details/#Components-of-registration-1","page":"Components of registration","title":"Components of registration","text":"","category":"section"},{"location":"details/#Apertured-mismatch-1","page":"Components of registration","title":"Apertured mismatch","text":"","category":"section"},{"location":"details/#","page":"Components of registration","title":"Components of registration","text":"As described in the documentation for RegisterCore, the mismatch between images is represented using an array where each element corresponds to a shift (translation) of a block of the image. From the demo in the cookbook, we can select a particular moving image, compute the mismatch, and visualize it:","category":"page"},{"location":"details/#","page":"Components of registration","title":"Components of registration","text":"moving = img[:,:,1]\nmms = mismatch_apertures(fixed, moving, aperture_centers, aperture_width, mxshift)\n# Turn the mismatch from NumDenom to a plain ratio (see RegisterCore docs)\nrat(x) = ratio(x, thresh)\nmmsr = map(mm->rat.(mm), mms)\n# Concatenate so we can see the whole 3×3 grid of mismatch arrays\nmmall = hvcat((3,3,3), parent.(mmsr)...)\nmaximum(mmall)","category":"page"},{"location":"details/#","page":"Components of registration","title":"Components of registration","text":"If you visualize mmall, you'll see something like this:","category":"page"},{"location":"details/#","page":"Components of registration","title":"Components of registration","text":"(Image: mmall)","category":"page"},{"location":"details/#","page":"Components of registration","title":"Components of registration","text":"This is a heatmap representing the mismatch data in each element of the 3×3 grid of apertures. The center of each square corresponds to \"no shift\"; as one moves towards the edge one gets to the mxshift that we chose. Darker means lower mismatch (with zero being black), and lighter meaning higher mismatch. For example, the left-center aperture has a minimum that is displaced vertically from the center; if you look back at the images at the end of the previous page, you can convince yourself that the left side of the moving image is indeed shifted vertically. This aperture's minimum is also relatively isotropic, reflecting the fact that the image has \"features\" that define both the vertical and horizontal shift with approximately similar precision. Conversely, in other regions the penalty for some movements is quite different from the penalty for others. For example, the right-center aperture is \"forgiving\" of shifts that have only a slight tilt from vertical; this is because the tripod leg on the right side of the image is the highest-contrast feature, and sliding along the axis of the leg introduces much less mismatch than sliding perpendicularly to the leg.","category":"page"},{"location":"details/#Regularization-1","page":"Components of registration","title":"Regularization","text":"","category":"section"},{"location":"details/#","page":"Components of registration","title":"Components of registration","text":"The \"naive\" optimum deformation is set by choosing the lowest value in each of these apertures. However, because some apertures have very little to constrain them (e.g., lower left), we additionally enforce \"smoothness\" in the deformation with the AffinePenalty, whose magnitude it set by λ. You can specify the value of λ yourself, or you can allow the algorithm to choose it for you.","category":"page"},{"location":"details/#","page":"Components of registration","title":"Components of registration","text":"If one repeats the calculation in our cookbook up through auto_λ, plotting λvec (vector of tested λ values) vs dp (\"data penalty\") yields the following graph:","category":"page"},{"location":"details/#","page":"Components of registration","title":"Components of registration","text":"(Image: lambda)","category":"page"},{"location":"details/#","page":"Components of registration","title":"Components of registration","text":"Larger values of λ force the deformation to become closer to an affine transformation. Since the actual underlying transformation is not affine, large λ values force the optimizer to choose a lower-quality alignment in order to make the deformation affine. For this reason, the data penalty is higher at large λ.","category":"page"},{"location":"details/#","page":"Components of registration","title":"Components of registration","text":"Roughly speaking, auto_λ attempts to choose λ so that one is near the lower kink in the sigmoid–-where λ is starting to make a difference, but that you're still dominated by the data. To ensure that this happens correctly, you need to choose a λrange that effectively spans the sigmoid.","category":"page"},{"location":"details/#","page":"Components of registration","title":"Components of registration","text":"The automatic choice may not be ideal (and it certainly takes more computation time), so you might consider experimenting with different λ and seeing which choice gives the best alignment.","category":"page"},{"location":"details/#Temporal-regularization-1","page":"Components of registration","title":"Temporal regularization","text":"","category":"section"},{"location":"details/#","page":"Components of registration","title":"Components of registration","text":"There is also a \"whole experiment\" mode that optimizes deformations for all images in a sequence simultaneously. In this mode, one can also supply a λt, which is a regularizer for changes in λ over time. This regularizer currently penalizes the sum-of-squared differences across time. Because real-world experiments sometimes have sudden movements, and the sum-of-squared differences smooths those transitions out, this mode is not currently recommended.","category":"page"},{"location":"cookbook/#cookbook-1","page":"Stack-by-stack optimization: a cookbook","title":"Stack-by-stack optimization: a cookbook","text":"","category":"section"},{"location":"cookbook/#","page":"Stack-by-stack optimization: a cookbook","title":"Stack-by-stack optimization: a cookbook","text":"For practical use with large images you might prefer the \"stack-by-stack registration\" section of BlockRegistrationScheduler. If you're using the scheduler, many parts of the rest of this cookbook do not apply. However, if your goal is to learn the internals, it's easier and more informative to start with BlockRegistration.","category":"page"},{"location":"cookbook/#","page":"Stack-by-stack optimization: a cookbook","title":"Stack-by-stack optimization: a cookbook","text":"Let's start with a simple two-dimensional demonstration. The code below is heavily annotated to explain what each step does.","category":"page"},{"location":"cookbook/#","page":"Stack-by-stack optimization: a cookbook","title":"Stack-by-stack optimization: a cookbook","text":"using FileIO, Images, Unitful, StaticArrays, ProgressMeter\nusing AxisArrays: Axis, AxisArray\nusing BlockRegistration\nusing RegisterMismatch  # no CUDA\n\n# Some physical units we may need (from the Unitful package)\nconst μm = u\"μm\"  # micrometers\nconst s  = u\"s\"   # seconds\n\n# Load your image (movie) into a variable called `img`.\n# It might look like this:\n#     img = load(\"myimage\")  # filename of your image\n# Here we will just use a demo script (see the `test/` directory)\nbrdir = dirname(dirname(pathof(BlockRegistration)))   # directory of BlockRegistration\ninclude(joinpath(brdir, \"test\", \"gen2d.jl\"));          # defines `img`\n\n# Note: if you're loading from a file type that doesn't return an AxisArray,\n# add something like this:\n#    img = AxisArray(img, (:y, :x, :time), (Δy, Δx, Δt))  # for 2d images + time\n# where Δy, Δx is the pixel spacing along y and x, respectively, and\n# Δt the time between successive frames. (The latter isn't really used for anything.)\n# For example:\n#    img = AxisArray(img, (:x, :y, :time), (1.15μm, 1.15μm, 0.2s));\n\n# If you need to select a region of interest, do something like\n#    img = view(img, 150:800, 50:600, :)\n\n# Now select your reference (\"fixed\") image. This chooses the middle\n# frame/stack, assuming you've set a :time axis\nfixedidx = (nimages(img) + 1) ÷ 2  # ÷ can be obtained with \"\\div[TAB]\"\n# Note: this next line extracts the timeslice.\n# This is like `img[:, :, t]` or `img[:, :, :, t]` but it\n# works for any dimensionality or ordering of the dimensions.\nfixed = img[timeaxis(img)(fixedidx)]\n\n# Important: inspect fixed to make sure it seems OK! You don't want to\n# align to an image that happens to have an artifact.\n\n# At very low SNR you might consider smoothing both fixed and moving before running\n# registration (see the JuliaImages documentation)\n\n## With the preliminaries out of the way, let's get started. Specify a few parameters.\n# Choose the maximum amount of movement you want to allow (set this by visual inspection)\nmxshift = (30, 30)  # 30 pixels along each spatial axis for a 2d+time image\n# Pick a grid size for your registration. Finer grids allow more\n# \"detail\" in the deformation, but also have more parameters and\n# therefore require higher SNR data.\ngridsize = (3, 3)   # it's fine to choose something anisotropic\n# Pick a threshold for sufficiency of data. The aim of this parameter is to prevent\n# the algorithm from considering solutions where the two images barely have any overlap,\n# e.g., where the algorithm chooses to align images\n#        A  A  A                  B  B  B\n#        A  A  A       and        B  B  B\n#        A  A  A                  B  B  B\n# as\n#                 A  A  A\n#                 A  A  A\n#                 A  A  O  B  B      (O = overlap region)\n#                       B  B  B\n#                       B  B  B\n# just to get all the high-SNR regions \"out of the way\".\n#\n# The choice below effectively requires that we have at least 1/4 of a\n# grid-block's worth of data before we take any results seriously.\nthresh_fac=(0.5)^ndims(fixed)\nthresh = (thresh_fac/prod(gridsize)) * length(fixed)\n# Set λrange. See info below. You can alternatively choose a single number, e.g.,\n#     λrange = 0.003\nλrange = (1e-6, 1.0)    # (lo, hi)\n\n## Calculated and pre-allocated parameters\n# grid geometry\naperture_centers = aperture_grid(size_spatial(img), gridsize)\naperture_width = default_aperture_width(fixed, gridsize)\nnodes = map(axes(fixed), gridsize) do ax, g\n    range(first(ax), stop=last(ax), length=g)\nend\n# allocate storage for quadratic model of blockwise mismatch data\nE0 = zeros(gridsize)\ncs = Array{Any}(undef, gridsize)\nQs = Array{Any}(undef, gridsize)\n\n# AffinePenalty handles regularization, penalizing any deformation in proportion to\n# the degree to which it disagrees with its own best-fit affine transformation.\n# λ (via λrange) specifies the weighting of this deformation penalty.\nap = AffinePenalty(nodes, first(λrange))\n\n# Now loop over each timeslice\nϕs, λs, errs = [], [], []  # storage for results (the deformation, chosen λ, and resid for each timeslice)\n@showprogress 1 for tidx in axes(img, Axis{:time})\n    moving = view(img, timeaxis(img)(tidx))\n\n    # Compute the mismatch for all deformations that are piecewise-constant\n    # over the grid.\n    mms = mismatch_apertures(fixed, moving, aperture_centers, aperture_width, mxshift)\n\n    # Some cameras generate fixed-pattern noise, which acts as an \"anchor\"\n    # preventing movement. Even if you can't see the fixed-pattern noise by\n    # eye, its cumulative effect over an entire block can be substantial.\n    # The hallmark is a \"cross\" pattern centered on the middle of each block of `mms`,\n    # which introduces a bias to choose a shift of 0 on a per-coordinate basis.\n    #\n    # The commented-out command below attempts to discard this noise.\n    # _Don't_ use it unless you know you need to, because bias correction can\n    # easily make the registration worse.\n    # On more modern sCMOS cameras this may not be necessary.\n    # correctbias!(mms)\n\n    # Construct a quadratic fit to the mismatch data in each block of the grid\n    # We'll use this to help initialize the deformation to a good starting value.\n    for i in eachindex(mms)\n        E0[i], cs[i], Qs[i] = qfit(mms[i], thresh; opt=false)\n    end\n\n    # Prepare for optimization\n    mmis = interpolate_mm!(mms)\n    if isa(λrange, Number)\n        # We've specified a particular value for λ\n        ϕ, mismatch = fixed_λ(cs, Qs, nodes, ap, mmis)\n        λ = λrange\n    else\n        # We've specified a range for λ. Try to choose a \"good value\" (see below)\n        ϕ, mismatch, λ, λvec, dp, quality = auto_λ(cs, Qs, nodes, ap, mmis, λrange)\n    end\n    # Save the result for later use. Of course you can save more data than this,\n    # e.g., the value of the mismatch might be an indication of quality.\n    push!(ϕs, ϕ)\n    push!(λs, λ)\n    push!(errs, mismatch)\nend\n\nall(errs .< 0.03)\n\n# output\n\ntrue","category":"page"},{"location":"cookbook/#","page":"Stack-by-stack optimization: a cookbook","title":"Stack-by-stack optimization: a cookbook","text":"If you prefer, you can put everything after the parameter settings (maxshift, gridsize, thresh, and λrange) into a function that you reuse across experiments.","category":"page"},{"location":"cookbook/#","page":"Stack-by-stack optimization: a cookbook","title":"Stack-by-stack optimization: a cookbook","text":"Let's look at the results. When you're registering \"big data,\" you will usually need to save the warped images to disk:","category":"page"},{"location":"cookbook/#","page":"Stack-by-stack optimization: a cookbook","title":"Stack-by-stack optimization: a cookbook","text":"# .cam is from ImagineFormat.jl (or use NRRD, etc.)\nopen(\"my_registered_image.cam\", \"w\") do file\n    warp!(Float32, file, img, ϕs; nworkers=3)\nend","category":"page"},{"location":"cookbook/#","page":"Stack-by-stack optimization: a cookbook","title":"Stack-by-stack optimization: a cookbook","text":"But if you're testing this on the small demo in \"test/gen2d.jl\", we can do it in memory:","category":"page"},{"location":"cookbook/#","page":"Stack-by-stack optimization: a cookbook","title":"Stack-by-stack optimization: a cookbook","text":"# Allocate storage for the warped image\nimgw = similar(img, Gray{Float32});   # eltype needs to be able to store NaN\nfor i = 1:nimages(img)\n    # Apply the deformation to the \"recorded\" image\n    imgw[:,:,i] = warp(img[:,:,i], ϕs[i])\nend","category":"page"},{"location":"cookbook/#results-1","page":"Stack-by-stack optimization: a cookbook","title":"Visualizing the results","text":"","category":"section"},{"location":"cookbook/#","page":"Stack-by-stack optimization: a cookbook","title":"Stack-by-stack optimization: a cookbook","text":"You can check the results with","category":"page"},{"location":"cookbook/#","page":"Stack-by-stack optimization: a cookbook","title":"Stack-by-stack optimization: a cookbook","text":"using ImageView\nimshow(imgw)","category":"page"},{"location":"cookbook/#","page":"Stack-by-stack optimization: a cookbook","title":"Stack-by-stack optimization: a cookbook","text":"If you try this demo, you'll see the strengths and weaknesses of BlockRegistration: for a \"minimize the mean square difference\" algorithm it's quite fast, and the warped image is better than the original, but it's certainly not perfect. For example, here is an overlay of the fixed image (the middle frame in the movie) in magenta and the first moving image (the first image in the movie) in green:","category":"page"},{"location":"cookbook/#","page":"Stack-by-stack optimization: a cookbook","title":"Stack-by-stack optimization: a cookbook","text":"Original Aligned\n(Image: orig1) (Image: align1)","category":"page"},{"location":"cookbook/#","page":"Stack-by-stack optimization: a cookbook","title":"Stack-by-stack optimization: a cookbook","text":"You can see the corrected alignment is quite good; the original has a fair amount of misalignment (as evidenced by the magenta and green, which indicates different intensities in the fixed and moving image), whereas after motion correction the two line up fairly closely (most pixels are very close to pure grayscale).","category":"page"},{"location":"cookbook/#","page":"Stack-by-stack optimization: a cookbook","title":"Stack-by-stack optimization: a cookbook","text":"But now let's look at the last image in the series, which has a different deformation:","category":"page"},{"location":"cookbook/#","page":"Stack-by-stack optimization: a cookbook","title":"Stack-by-stack optimization: a cookbook","text":"Original Aligned\n(Image: orig2) (Image: align2)","category":"page"},{"location":"cookbook/#","page":"Stack-by-stack optimization: a cookbook","title":"Stack-by-stack optimization: a cookbook","text":"The aligned pair is certainly better, but far from perfect.","category":"page"},{"location":"cookbook/#","page":"Stack-by-stack optimization: a cookbook","title":"Stack-by-stack optimization: a cookbook","text":"Next we dive a bit deeper to explain a few key features of this approach, and to explore some of the ways you can improve on these results.","category":"page"},{"location":"improving/#Improving-alignment-1","page":"Improving alignment","title":"Improving alignment","text":"","category":"section"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"In the cookbook, the last timeslice was particularly poorly aligned with the fixed image. Here we explore some options for improving the results.","category":"page"},{"location":"improving/#Adjusting-λ-1","page":"Improving alignment","title":"Adjusting λ","text":"","category":"section"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"The value chosen by auto_λ should be viewed as a guide only; in particular, if you're registering a large data set, the fact that auto_λ runs many registrations of the same image pairs means it will take a long time. One good approach is to run auto_λ on a small subset of stacks and see what kind of values it picks; then, adopt something similar as a fixed value of λ for the whole experiment.","category":"page"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"In practice it often seems to choose too large of a value; if we re-run the cookbook with a fixed value of λ = 1e-6, we seem to do somewhat better on that troublesome final image:","category":"page"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"(Image: manual λ)","category":"page"},{"location":"improving/#Iterative-refinement-1","page":"Improving alignment","title":"Iterative refinement","text":"","category":"section"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"It is possible to use the solution as an initializer to iteratively improve the alignment. The idea is that","category":"page"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"moving = img[:,:,end]\nϕ1 = ϕs[end]\nmovw1 = warp(moving, ϕ1)","category":"page"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"represents a closer match to fixed than moving itself; we can then calculate a ϕ2 that aligns movw1 to fixed and then compose them:","category":"page"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"mms = mismatch_apertures(fixed, movw1, aperture_centers, aperture_width, mxshift)\nfor i in eachindex(mms)\n    E0[i], cs[i], Qs[i] = qfit(mms[i], thresh; opt=false)\nend\nmmis = interpolate_mm!(mms)\nϕ2, mismatch = auto_λ(cs, Qs, nodes, ap, mmis, λrange)","category":"page"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"ϕ2 should approximately align movw1 to fixed, and consequently","category":"page"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"using Interpolations\nϕtot = interpolate(ϕ1)(ϕ2)","category":"page"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"should align moving to fixed:","category":"page"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"(Image: iterative)","category":"page"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"You can see that this is a somewhat better alignment than our first attempt. One does not have to stop at a first iteration, one can repeat this process for as long as it continues to improve the alignment.","category":"page"},{"location":"improving/#Changing-the-grid-size-1","page":"Improving alignment","title":"Changing the grid size","text":"","category":"section"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"Another approach is to use more grid points, allowing a more fine-scaled deformation:","category":"page"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"gridsize = (9, 9)\n\n...\n# repeat all the other calculations for the final image in the time series\n...\n\nmovw = warp(moving, ϕ)\nimshow(colorview(RGB, fixed, movw, fixed); name=\"9x9\")","category":"page"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"(Image: 9x9)","category":"page"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"The \"wobble\" in the leg is an indication that the increasing number of degrees of freedom is making it harder to determine the correct deformation on the finest scales. It can take some experimentation to find grid sizes that work well.","category":"page"},{"location":"improving/#RegisterHindsight-1","page":"Improving alignment","title":"RegisterHindsight","text":"","category":"section"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"So far, every operation we've used works prospectively: we try to predict the mismatch based on shifting entire blocks of the image, and we adopt the deformation that minimizes this prospective mismatch. More conventional registration frameworks directly model the mismatch associated with moving(ϕ(x)) and perform descent on ϕ. RegisterHindsight lets you optimize ϕ in this manner:","category":"page"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"moving, ϕ0, λ = img[:,:,end], ϕs[end], λs[end]\nϕ = interpolate!(copy(ϕ0))        # not the same as `interpolate(ϕ0)`, see docs\nap = AffinePenalty(ϕ.nodes, λ/100)   # note /100! `auto_λ` often seems to choose high\np, p0 = RegisterHindsight.optimize!(ϕ, ap, fixed, moving)","category":"page"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"If you warp moving you obtain the following:","category":"page"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"(Image: hindsight)","category":"page"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"You can see this is considerably better, though of course it was far slower.","category":"page"},{"location":"improving/#","page":"Improving alignment","title":"Improving alignment","text":"If you see the registration gets worse, it's almost surely a sign that λ was too high.","category":"page"},{"location":"#BlockRegistration.jl-1","page":"Home","title":"BlockRegistration.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BlockRegistration is designed to perform non-rigid image registration–specifically, motion correction–for a time series of images. It aligns images by attempting to minimize the mean square difference between images, a strategy that does not require \"control points\" or \"features\", as BlockRegistration was designed to work with relatively low signal-to-noise ratio images common in biomedical imaging. BlockRegistration works on images/movies with an arbitrary number of spatial dimensions and a single temporal dimension.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Because it was designed to handle the very large data sets produced by light sheet microscopy, it prioritizes speed over quality, primarily by modeling deformations as piecewise-constant over extended blocks of the image during its optimization phase. It has several apparently-innovative features designed to increase the likelihood of ending up near the global optimum, for example by initializing the deformation via a quadratic approximation to the blockwise mismatch data.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Documentation is still a work in progress, and there is no publication yet, but a few of the key concepts are described in the documentation for some of the dependent modules (see below).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"BlockRegistration is written in the Julia programming language.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"If you don't already have it, add HolyLabRegistry as a registry. Then from package mode just do","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pkg> add BlockRegistration RegisterMismatch","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If you have GPUs available, you may also want to add RegisterMismatchCuda. This requires that you have nvidia drivers installed on your system.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"See also BlockRegistrationScheduler, which allows you to parallelize registration across worker processes. It works for both CPU (RegisterMismatch) and GPU (RegisterMismatchCuda), though for GPU you need a dedicated GPU card for each worker process.","category":"page"},{"location":"#Orienting-yourself-1","page":"Home","title":"Orienting yourself","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BlockRegistration is a meta-package that merely re-exports several lower-level modules, of which the main ones likely to be of interest to users are (* indicates that the package has additional documentation):","category":"page"},{"location":"#","page":"Home","title":"Home","text":"*RegisterCore: basic types and the overall framework\n*RegisterDeformation: deformations (warps) of space\nRegisterMismatch/RegisterMismatchCuda: computing mismatch data from raw images\nRegisterFit: approximating mismatch data with simple models\nRegisterPenalty: regularized objective functions for use in optimization\nRegisterOptimize: performing optimization to align images","category":"page"},{"location":"#","page":"Home","title":"Home","text":"When you're using the package, choose either CPU mode:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using BlockRegistration\nusing RegisterMismatch","category":"page"},{"location":"#","page":"Home","title":"Home","text":"or GPU mode:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using BlockRegistration\nusing RegisterMismatchCuda","category":"page"},{"location":"#","page":"Home","title":"Home","text":"You can invoke help with ? followed by the name of a module; for example, ?RegisterCore will provide an overview of the RegisterCore module (a good place to start if you're trying to get a handle on the basic underpinnings). You'll see a list of major functions in the module, and generally each of these has its own documentation. Given that \"published\" documentation is still a bit sparse, also consider looking at the code in each package's test/ folder as an example of how to use these modules.","category":"page"}]
}
